"""重构后的XBRL解析器

使用智能表格解析机制，动态识别表头，避免硬编码列索引。
采用更灵活和鲁棒的解析策略。
"""

import re
from pathlib import Path
from typing import Optional, List, Dict, Any, Tuple
from decimal import Decimal, InvalidOperation
from datetime import date

from bs4 import BeautifulSoup, Tag
import chardet
from src.core.logging import get_logger
# 最终修复：导入真正的SQLAlchemy ORM模型，而不是使用本地的dataclass
from src.models.fund_data import FundReport, AssetAllocation, TopHolding, IndustryAllocation
from src.utils.ai_utils import enhance_basic_info_extraction, enhance_table_extraction


class SmartTableParser:
    """智能表格解析器"""

    def __init__(self):
        self.logger = get_logger("smart_table_parser")
        # 增强的表头关键词映射
        self.header_mappings = {
            # 资产配置表头
            "asset_type": ["资产类别", "投资类别", "资产类型", "大类资产", "资产", "投资品种", "投资标的"],
            "market_value": ["市值", "公允价值", "金额", "投资金额", "市场价值", "价值", "投资市值", "持仓市值"],
            "percentage": ["占比", "比例", "百分比", "占净值比例", "占基金资产净值比例", "占基金净值比例", "净值占比"],
            # 持仓表头
            "security_name": ["证券名称", "股票名称", "证券简称", "名称", "持仓名称", "股票简称", "证券"],
            "security_code": ["证券代码", "股票代码", "代码", "证券代码"],
            "shares": ["持股数量", "数量", "股数", "持有股数", "持仓数量", "持有数量"],
            "rank": ["序号", "排名", "名次", "排序"],
            # 行业配置表头
            "industry_name": ["行业名称", "行业", "申万行业", "行业分类", "行业类别", "所属行业"],
            "industry_code": ["行业代码", "代码", "申万代码"],
        }

        # 表格识别关键词优化
        self.table_keywords = {
            "asset_allocation": {
                "primary": ["资产配置", "投资组合", "资产类别", "大类资产"],
                "secondary": ["股票", "债券", "现金", "银行存款", "其他资产"],
            },
            "top_holdings": {
                "primary": ["前十大", "重仓股", "前10大", "主要持仓", "股票投资"],
                "secondary": ["持股", "投资明细", "重仓", "前十名"],
            },
            "industry_allocation": {
                "primary": ["行业配置", "行业分布", "行业投资", "申万行业"],
                "secondary": ["行业分类", "行业类别", "按行业"],
            },
        }

    def identify_table_type(self, table: Tag) -> Optional[str]:
        """优化的表格类型识别 - 增强版本，包含更复杂的评分算法和调试日志"""
        table_text = table.get_text().lower()
        exclude_keywords = ["关联方", "交易", "费用", "审计", "托管", "会计", "声明", "签字", "附注"]
        
        # 计算排除关键词的负面权重
        exclude_penalty = sum(2 for keyword in exclude_keywords if keyword in table_text)
        
        # 检查表格基本结构
        rows = table.find_all("tr")
        if len(rows) < 3:
            return None
            
        # 检查是否有数值数据（提高表格识别准确性）
        has_numerical_data = bool(re.search(r'\d+[.,]\d+', table_text))
        numerical_bonus = 2 if has_numerical_data else 0
        
        # 计算每种表格类型的得分
        scores = {}
        for table_type, keywords in self.table_keywords.items():
            primary_score = sum(3 for kw in keywords["primary"] if kw in table_text)
            secondary_score = sum(1 for kw in keywords["secondary"] if kw in table_text)
            
            # 总得分 = 主要关键词得分 + 次要关键词得分 + 数值数据奖励 - 排除关键词惩罚
            total_score = primary_score + secondary_score + numerical_bonus - exclude_penalty
            scores[table_type] = max(0, total_score)  # 确保得分不为负数
        
        # 记录调试信息
        if any(score > 0 for score in scores.values()):
            best_type = max(scores, key=scores.get)
            self.logger.debug("table_identification", 
                            table_rows=len(rows),
                            has_numerical=has_numerical_data,
                            exclude_penalty=exclude_penalty,
                            scores=scores,
                            best_guess=best_type,
                            best_score=scores[best_type])
            
            # 只有当最佳得分达到阈值时才返回类型
            if scores[best_type] >= 3:
                return best_type
        
        return None

    def parse_table_headers(self, table: Tag) -> Dict[str, int]:
        """增强的动态表头解析"""
        best_mapping, best_score = {}, 0
        for row in table.find_all("tr")[:5]:
            cells = row.find_all(["th", "td"])
            if len(cells) < 2: continue
            
            current_mapping, score = {}, 0
            for i, cell in enumerate(cells):
                cell_text = cell.get_text().strip().lower()
                for field, keywords in self.header_mappings.items():
                    if any(kw in cell_text for kw in keywords):
                        current_mapping[field] = i
                        score += 1
                        break
            
            if score > best_score:
                best_mapping, best_score = current_mapping, score
        return best_mapping

    def _parse_decimal(self, text: str) -> Optional[Decimal]:
        """从文本中解析Decimal数值"""
        if not text or text.strip() in ["-", "--", "—", "N/A", "n/a"]: return None
        try:
            cleaned = re.sub(r"[^\d.,-]", "", text)
            return Decimal(cleaned.replace(",", ""))
        except (InvalidOperation, ValueError):
            return None

    def extract_cell_value(self, cell: Tag, value_type: str = "text") -> Any:
        """提取并解析单元格的值"""
        text = cell.get_text().strip()
        if value_type == "decimal":
            return self._parse_decimal(text)
        return text if text and text not in ["-", "--", "—", "N/A", "n/a"] else None

    def parse_asset_allocation_table(self, table: Tag) -> List[AssetAllocation]:
        """解析资产配置表并返回AssetAllocation对象列表"""
        headers = self.parse_table_headers(table)
        if not headers: return []
        
        allocations = []
        for row in table.find_all("tr")[1:]:
            cells = row.find_all(["td", "th"])
            if len(cells) < len(headers): continue
            
            try:
                asset_type = self.extract_cell_value(cells[headers["asset_type"]])
                market_value = self.extract_cell_value(cells[headers["market_value"]], "decimal")
                percentage = self.extract_cell_value(cells[headers["percentage"]], "decimal")
                
                if asset_type and (market_value is not None or percentage is not None):
                    allocations.append(AssetAllocation(
                        asset_type=asset_type,
                        asset_name=asset_type,
                        market_value=market_value,
                        percentage=percentage
                    ))
            except (KeyError, IndexError):
                continue
        return allocations

    def parse_top_holdings_table(self, table: Tag) -> List[TopHolding]:
        """解析前十大持仓表并返回TopHolding对象列表"""
        headers = self.parse_table_headers(table)
        if not headers: return []

        holdings = []
        rank = 1
        for row in table.find_all("tr")[1:]:
            if rank > 10: break
            cells = row.find_all(["td", "th"])
            if len(cells) < len(headers): continue

            try:
                name = self.extract_cell_value(cells[headers["security_name"]])
                if name:
                    holdings.append(TopHolding(
                        holding_type="股票",
                        security_code=self.extract_cell_value(cells[headers["security_code"]]) if "security_code" in headers else None,
                        security_name=name,
                        shares=self.extract_cell_value(cells[headers["shares"]], "decimal") if "shares" in headers else None,
                        market_value=self.extract_cell_value(cells[headers["market_value"]], "decimal"),
                        percentage=self.extract_cell_value(cells[headers["percentage"]], "decimal"),
                        rank=rank
                    ))
                    rank += 1
            except (KeyError, IndexError):
                continue
        return holdings

    def parse_industry_allocation_table(self, table: Tag) -> List[IndustryAllocation]:
        """解析行业配置表并返回IndustryAllocation对象列表"""
        headers = self.parse_table_headers(table)
        if not headers: return []

        allocations = []
        for row in table.find_all("tr")[1:]:
            cells = row.find_all(["td", "th"])
            if len(cells) < len(headers): continue

            try:
                name = self.extract_cell_value(cells[headers["industry_name"]])
                if name:
                    allocations.append(IndustryAllocation(
                        industry_name=name,
                        market_value=self.extract_cell_value(cells[headers["market_value"]], "decimal"),
                        percentage=self.extract_cell_value(cells[headers["percentage"]], "decimal")
                    ))
            except (KeyError, IndexError):
                continue
        return allocations


class XBRLParser:
    """重构后的XBRL解析器"""

    def __init__(self):
        self.logger = get_logger("xbrl_parser")
        self.table_parser = SmartTableParser()
        self.patterns = {
            "fund_code": [r"基金代码[：:]?\s*([A-Za-z0-9]{6})"],
            "fund_name": [r"基金名称[：:]?\s*([^\n\r]+)"],
            "report_period": [r"报告期自\s*(\d{4}年\d{1,2}月\d{1,2}日)\s*至\s*(\d{4}年\d{1,2}月\d{1,2}日)"],
            "net_asset_value": [r"基金份额净值[：:]?\s*([\d.]+)"],
            "total_net_assets": [r"资产总计[：:]?\s*([\d,]+\.\d+)"],
        }

    def parse_file(self, file_path: Path) -> Optional[FundReport]:
        """解析XBRL文件并返回一个FundReport ORM对象"""
        bound_logger = self.logger.bind(file_path=str(file_path))
        try:
            content = self._read_file_with_encoding(file_path)
            if not content: return None
            
            soup = BeautifulSoup(content, "html.parser")
            
            fund_report = FundReport()
            
            # 现在传递soup对象，而不是纯文本
            self._parse_basic_info(soup, fund_report)
            self._parse_tables(soup, fund_report)

            bound_logger.info("xbrl_parser.parse_complete", fund_code=fund_report.fund_code)
            return fund_report

        except Exception as e:
            bound_logger.error("xbrl_parser.parse_error", error=str(e))
            return None

    def _read_file_with_encoding(self, file_path: Path) -> Optional[str]:
        """自动检测编码并读取文件"""
        try:
            with open(file_path, "rb") as f:
                raw_data = f.read()
            encoding = chardet.detect(raw_data)["encoding"] or "utf-8"
            return raw_data.decode(encoding, errors="ignore")
        except IOError as e:
            self.logger.warning("xbrl_parser.file_read_error", error=str(e))
            return None

    def _find_value_by_label(self, soup: BeautifulSoup, label_patterns: List[str]) -> Optional[str]:
        """
        通过标签文本查找对应的值。
        这是一个更健壮的方法，它利用HTML结构而不是全局regex。
        增强版本包含更多导航策略和模式匹配。
        """
        for pattern in label_patterns:
            try:
                # 查找包含标签文本的元素。使用 text=... 比 get_text() 更精确
                label_tag = soup.find(text=re.compile(pattern, re.IGNORECASE))
                if label_tag:
                    self.logger.debug(f"Found label for '{pattern}' in tag: {label_tag.parent.name}")
                    
                    # 策略1：值在同一个标签内，但在标签文本之后
                    # 例如: <td>基金代码 001234</td>
                    match = re.search(f"{pattern}\\s*[:：]?\\s*([\\w.-]+)", label_tag, re.IGNORECASE)
                    if match and len(match.group(1)) > 2:
                        return match.group(1)

                    # 策略2：值在父节点的文本中
                    parent_text = label_tag.parent.get_text(strip=True)
                    match = re.search(f"{pattern}\\s*[:：]?\\s*([\\w.-]+)", parent_text, re.IGNORECASE)
                    if match and len(match.group(1)) > 2:
                        return match.group(1)

                    # 策略3：值在下一个兄弟节点中
                    next_sibling = label_tag.find_next_sibling()
                    if next_sibling and next_sibling.get_text(strip=True):
                        return next_sibling.get_text(strip=True)
                    
                    # 策略4：值在父节点的下一个兄弟节点中
                    parent_sibling = label_tag.parent.find_next_sibling()
                    if parent_sibling and parent_sibling.get_text(strip=True):
                        return parent_sibling.get_text(strip=True)

                    # 策略5: 值在同一个表格行(tr)的下一个单元格(td)
                    row = label_tag.find_parent('tr')
                    if row:
                        # 找到包含标签的单元格
                        label_cell = label_tag.find_parent('td') or label_tag.find_parent('th')
                        if label_cell:
                            value_cell = label_cell.find_next_sibling('td')
                            if value_cell and value_cell.get_text(strip=True):
                                return value_cell.get_text(strip=True)
                    
                    # 策略6: 值在包含标签的div的下一个div中
                    div_parent = label_tag.find_parent('div')
                    if div_parent:
                        next_div = div_parent.find_next_sibling('div')
                        if next_div and next_div.get_text(strip=True):
                            return next_div.get_text(strip=True)
                    
                    # 策略7: 值在同一个段落(p)的后续文本中
                    p_parent = label_tag.find_parent('p')
                    if p_parent:
                        p_text = p_parent.get_text(strip=True)
                        match = re.search(f"{pattern}\\s*[:：]?\\s*([\\w.-]+)", p_text, re.IGNORECASE)
                        if match and len(match.group(1)) > 2:
                            return match.group(1)
                    
                    # 策略8: 值在标签后的任何文本节点中（更宽泛的搜索）
                    next_text = label_tag.find_next(text=True)
                    if next_text and next_text.strip():
                        # 尝试从下一个文本节点中提取数值
                        text_content = next_text.strip()
                        if re.match(r'^[\d.,]+$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content$', text_content):
                            return text_content

            except Exception as e:
                self.logger.debug(f"Error finding value for pattern '{pattern}': {e}")
                continue
        return None

    def _parse_basic_info(self, soup: BeautifulSoup, report: FundReport):
        """解析基本信息并填充到FundReport对象（使用结构化查找 + AI增强）"""
        # Stage 1: 使用更可靠的结构化查找方法
        report.fund_code = self._find_value_by_label(soup, [r"基金主代码", r"基金代码"])
        report.fund_name = self._find_value_by_label(soup, [r"基金名称", r"基金简称"])
        
        # 对于更复杂的值，可以继续使用更精确的regex在找到的文本上
        nav_str = self._find_value_by_label(soup, [r"报告期末基金份额净值", r"份额净值"])
        if nav_str:
            match = re.search(r"([\d.]+)", nav_str)
            if match:
                try:
                    report.net_asset_value = Decimal(match.group(1))
                except InvalidOperation:
                    self.logger.warning(f"Could not parse net_asset_value from '{nav_str}'")

        total_assets_str = self._find_value_by_label(soup, [r"报告期末基金资产净值", r"资产净值"])
        if total_assets_str:
            match = re.search(r"([\d,]+\.\d{2})", total_assets_str)
            if match:
                try:
                    report.total_net_assets = Decimal(match.group(1).replace(",", ""))
                except InvalidOperation:
                    self.logger.warning(f"Could not parse total_net_assets from '{total_assets_str}'")

        # Stage 2: AI-Enhanced Extraction for missing fields
        try:
            ai_results = enhance_basic_info_extraction(soup, report)
            if ai_results:
                # Apply AI results for missing fields only
                if not report.fund_code and ai_results.get('fund_code'):
                    report.fund_code = ai_results['fund_code']
                
                if not report.fund_name and ai_results.get('fund_name'):
                    report.fund_name = ai_results['fund_name']
                
                if not report.net_asset_value and ai_results.get('net_asset_value'):
                    try:
                        report.net_asset_value = Decimal(str(ai_results['net_asset_value']))
                    except (InvalidOperation, TypeError, ValueError):
                        self.logger.warning("AI returned invalid net_asset_value", value=ai_results['net_asset_value'])
                
                if not report.total_net_assets and ai_results.get('total_net_assets'):
                    try:
                        report.total_net_assets = Decimal(str(ai_results['total_net_assets']))
                    except (InvalidOperation, TypeError, ValueError):
                        self.logger.warning("AI returned invalid total_net_assets", value=ai_results['total_net_assets'])
        
        except Exception as e:
            self.logger.warning("AI basic info extraction failed", error=str(e))

    def _parse_tables(self, soup: BeautifulSoup, report: FundReport):
        """解析所有表格并填充到FundReport对象（使用规则解析 + AI增强）"""
        # Stage 1: Rule-based table parsing
        tables = soup.find_all("table")
        for table in tables:
            table_type = self.table_parser.identify_table_type(table)
            if table_type == "asset_allocation":
                report.asset_allocations = self.table_parser.parse_asset_allocation_table(table)
            elif table_type == "top_holdings":
                report.top_holdings = self.table_parser.parse_top_holdings_table(table)
            elif table_type == "industry_allocation":
                report.industry_allocations = self.table_parser.parse_industry_allocation_table(table)

        # Stage 2: AI-Enhanced table extraction for missing data
        try:
            # Check if asset allocation data is missing or insufficient
            if not report.asset_allocations or len(report.asset_allocations) == 0:
                ai_results = enhance_table_extraction(soup, "asset_allocation")
                if ai_results.get("asset_allocations"):
                    report.asset_allocations = []
                    for item in ai_results["asset_allocations"]:
                        if item.get("asset_type"):
                            allocation = AssetAllocation(
                                asset_type=item["asset_type"],
                                asset_name=item["asset_type"],
                                market_value=Decimal(str(item["market_value"])) if item.get("market_value") else None,
                                percentage=Decimal(str(item["percentage"])) if item.get("percentage") else None
                            )
                            report.asset_allocations.append(allocation)

            # Check if top holdings data is missing or insufficient
            if not report.top_holdings or len(report.top_holdings) == 0:
                ai_results = enhance_table_extraction(soup, "top_holdings")
                if ai_results.get("top_holdings"):
                    report.top_holdings = []
                    for i, item in enumerate(ai_results["top_holdings"][:10], 1):  # Limit to top 10
                        if item.get("security_name"):
                            holding = TopHolding(
                                holding_type="股票",
                                security_code=item.get("security_code"),
                                security_name=item["security_name"],
                                shares=Decimal(str(item["shares"])) if item.get("shares") else None,
                                market_value=Decimal(str(item["market_value"])) if item.get("market_value") else None,
                                percentage=Decimal(str(item["percentage"])) if item.get("percentage") else None,
                                rank=item.get("rank", i)
                            )
                            report.top_holdings.append(holding)

            # Check if industry allocation data is missing or insufficient
            if not report.industry_allocations or len(report.industry_allocations) == 0:
                ai_results = enhance_table_extraction(soup, "industry_allocation")
                if ai_results.get("industry_allocations"):
                    report.industry_allocations = []
                    for item in ai_results["industry_allocations"]:
                        if item.get("industry_name"):
                            allocation = IndustryAllocation(
                                industry_name=item["industry_name"],
                                market_value=Decimal(str(item["market_value"])) if item.get("market_value") else None,
                                percentage=Decimal(str(item["percentage"])) if item.get("percentage") else None
                            )
                            report.industry_allocations.append(allocation)

        except Exception as e:
            self.logger.warning("AI table extraction failed", error=str(e))
